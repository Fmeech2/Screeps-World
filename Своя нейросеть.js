// ¬озможные части тела
const „ј—“»_“≈Ћј = ["MOVE", "ATTACK", "RANGED_ATTACK", "HEAL", "TOUGH", "ѕ”—“ќ"];

//‘итнес функци€
function оценитьћощь рипа(тело рипа, тело¬рага) {
    //”читываем замедление передвижение из-за перевеса крипа
    let усталость рипа = тело рипа.filter(часть“ела => часть“ела != "MOVE").length * 2 - тело рипа.filter(часть“ела => часть“ела === "MOVE").length * 2;
    if (усталость рипа <= 0) усталость рипа = 1;
    else усталость рипа = усталость рипа / 2 + 1;
    let усталость¬рага = 1; // ѕредполагаем, что враг всегда мобильный
    //ћожно будет в будующем легко мен€ть хп  рипу на входе, в зависимости от количества частей тела
    let хп рипа = 50 * 100;
    let хп¬рага = 50 * 100;
    // —имул€ци€ бо€ (в реальной игре это зависит от движка Screeps)
    // ¬озвращаем награду: 1 Ч победа, 0 Ч поражение
    let наш–ейтинг =
        (тело рипа.filter(часть“ела => часть“ела === "ATTACK").length * 30 +
            тело рипа.filter(часть“ела => часть“ела === "RANGED_ATTACK").length * 15)
        / усталость рипа
        * (5000 / хп рипа);
    //усталось крипа не добавл€етс€ вражескому крипу, потому что предполагаетс€ что крип будет учитьс€ на итак адекватном вражеском крипе, без 50 частей ј“ј »
    let вражеский–ейтинг =
        (тело¬рага.filter(часть“ела => часть“ела === "ATTACK").length * 30 +
            тело¬рага.filter(часть“ела => часть“ела === "RANGED_ATTACK").length * 30)
        / усталость¬рага
        * (5000 / хп¬рага);

    //“аким образом наш  рип сейчас дерЄтс€ так, будто бы части тела не отламываютс€ до самой смерти, а враг всегда действует идеальным алгоритмом и сильнее в 2 раза
    return наш–ейтинг / вражеский–ейтинг;//¬ощвращает не идеальный 1, а % хп который наш  рип успел бы отн€ть у вражеского крипа перед смертью
}

// лас ћќ≈… нейроной сети
class ѕроста€ќднослойна€Ќейросеть {
    веса = [];

    constructor() {
        //«аполн€ем все нейроны случайными весами дл€ каждой части тела | токинизаци€ 
        for (let i = 0; i < 50; i++) {
            this.веса[i] = [];//»нициирум массив, потому что так хочет JS
            for (let j = 0; j < „ј—“»_“≈Ћј.length; j++) {
                //“еперь у каждого слота под тело, будут все вариации весов всех тел | вес = от -1 до 1
                this.веса[i][j] = Math.random() * 2 - 1;
            }
        }
    }

    //‘ункци€ прогноза. Ќо € бы еЄ назвал "‘ункцией выбора лучшей комбинации частей тела дл€ крипа на основе знаний обученной »»" ..длинное название, не правда ли?
    прогноз() {
        const выход = [];
        const выход“окинизированный = [];
        for (let i = 0; i < 50; i++) {
            let индекс—ћакс–ейтингом = 0;
            //¬ыбираем токен/индекс части тела с максимальным рейтингом
            for (let j = 0; j < „ј—“»_“≈Ћј.length; j++) {
                if (this.веса[i][индекс—ћакс–ейтингом] < this.веса[i][j])
                    индекс—ћакс–ейтингом = j;
            }
            выход“окинизированный[i] = индекс—ћакс–ейтингом;
        }
        //ѕреобразуем массив токенов в массив соответствующих частей тела
        for (let i = 0; i < 50; i++) {
            выход[i] = „ј—“»_“≈Ћј[выход“окинизированный[i]];
        }
        return выход;
    }

    //—оздать копию массива весов (используетс€ в создании наследников)
    копировать¬еса() {
        const клон = new ѕроста€ќднослойна€Ќейросеть();
        клон.веса = this.веса.map(р€д => [...р€д]);//ѕолное дублирование массива, вместо дуболировани€ ссылок
        return клон;
    }

    //ћутаци€ весов
    мутаци€(силаћутации = 0.1, веро€тностьћутации = 0.1) {
        for (let i = 0; i < 50; i++) {
            for (j = 0; j < „ј—“»_“≈Ћј.length; j++) {
                if (Math.random() < веро€тностьћутации)
                    this.веса[i][j] = this.веса[i][j] + (Math.random() * 2 - 1) * силаћутации;
            }
        }
    }
}

// ласс дл€ эволюции
class Ёвлюци€ {
    попул€ци€ = []; //¬ попул€цию вноситс€ множество обьектов класса ѕроста€ќднослойна€Ќейросеть()
    тело¬рага; //Ќе поверишь
    constructor(размерѕопул€ции, тело¬рага) {
        //—оздание попул€ции из случайных сетей
        for (let i = 0; i < размерѕопул€ции; i++) {
            this.попул€ци€[i] = new ѕроста€ќднослойна€Ќейросеть();
        }
        this.тело¬рага = тело¬рага;
    }

    //ќценка всех крипов в попул€ции
    оценить риповѕопул€ции() {
        const результаты=[];
        for (let i = 0; i < this.попул€ци€.length; i++) {
            const сеть рипа = this.попул€ци€[i];
            const тело рипа = сеть рипа.прогноз();
            const награда = оценитьћощь рипа(тело рипа, this.тело¬рага);
            результаты.push({ сеть рипа: сеть рипа, награда: награда });//—оздать массив = [массив обьектов крипа, массив награды]
        }
        return результаты;
    }

}