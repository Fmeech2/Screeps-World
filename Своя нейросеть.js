const MOVE = 1;
const ATTACK = 2;
const RANGED_ATTACK = 3;
const HEAL = 4;
const TOUGH = 5;

function нейрон(вход, вес) {
    let сумма = 0;
    //Перемножаем входные данные на вес
    for (let i = 0; i < вход.length; i++) {
        сумма = сумма + вход[i] * вес[i];
    }
    //Активационная функция (сигмойда)
    return 1 / (1 + Math.exp(-сумма));
}

function обучение(вход, вес, ожидаемый_результат, скорость_обучения) {
    let выход = нейрон(вход, вес);
    let ошибка = ожидаемый_результат - выход;

    //Корректируем веса
    for (let i = 0; i < вес.length; i++) {
        вес[i] = вес[i] + скорость_обучения * ошибка * вход[i];//Гражиентный спуск (почему мы умнажаем на вход[i] я так и не понял)
    }
}

//Тестируем код, на тестовых данных
let вход = [
    [MOVE, MOVE, ATTACK, ATTACK],
    [ATTACK, ATTACK, MOVE, MOVE],
    [TOUGH, MOVE, MOVE, ATTACK],
    [TOUGH, TOUGH, MOVE, MOVE],
    [MOVE, MOVE, RANGED_ATTACK, RANGED_ATTACK],
    [TOUGH, MOVE, MOVE, RANGED_ATTACK],
    [ATTACK, ATTACK, ATTACK, MOVE],
    [MOVE, ATTACK, ATTACK, ATTACK],

    [ATTACK, ATTACK, ATTACK, ATTACK],
    [MOVE, MOVE, MOVE, MOVE],
    [TOUGH, TOUGH, TOUGH, TOUGH],
    [HEAL, HEAL, HEAL, HEAL],
    [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK],
];
//let вес = [Math.random(), Math.random(), Math.random(),Math.random(), Math.random()];
let вес = [0.1, 0.1, 0.1, 0.1, 0.1];
let ожидаемый_результат = [
    7 / 9,
    7 / 9,
    4 / 9,
    0.01,
    (7 / 2) / 9,
    (4 / 2) / 9,
    6 / 9,
    9 / 9,

    0.1,
    0.1,
    0.05,
    0.05,
    0.2,
]; //Самый сильный ближний бой крип
let скорость_обучения = 0.1;

/*
console.log("До обучения:", вес);
for (let i = 0; i < 1000; i++) {
    for (j = 0; j < вход.length; j++) {
        обучение(вход[j], вес, ожидаемый_результат[j], скорость_обучения);
    }
}
console.log("После обучения:", вес);
console.log(нейрон(вход[0], вес) + " = 1?");
*/

























function оценитьМощьКрипа(телоКрипа, телоВрага) {
    //Учитываем замедление передвижение из-за перевеса крипа
    let усталостьКрипа = телоКрипа.filter(частьТела => частьТела != "MOVE").length * 2 - телоКрипа.filter(частьТела => частьТела === "MOVE").length * 2;
    if (усталостьКрипа <= 0) усталостьКрипа = 1;
    else усталостьКрипа = усталостьКрипа / 2 + 1;
    let усталостьВрага = 1; // Предполагаем, что враг всегда мобильный
    //Можно будет в будующем легко менять хп Крипу на входе, в зависимости от количества частей тела
    let хпКрипа = 50 * 100;
    let хпВрага = 50 * 100;
    // Симуляция боя (в реальной игре это зависит от движка Screeps)
    // Возвращаем награду: 1 — победа, 0 — поражение
    let нашРейтинг =
        (телоКрипа.filter(частьТела => частьТела === "ATTACK").length * 30 +
            телоКрипа.filter(частьТела => частьТела === "RANGED_ATTACK").length * 15)
        / усталостьКрипа
        * (5000 / хпКрипа);
    //усталось крипа не добавляется вражескому крипу, потому что предполагается что крип будет учиться на итак адекватном вражеском крипе, без 50 частей АТАКИ
    let вражескийРейтинг =
        (телоВрага.filter(частьТела => частьТела === "ATTACK").length * 30 +
            телоВрага.filter(частьТела => частьТела === "RANGED_ATTACK").length * 30)
        / усталостьВрага
        * (5000 / хпВрага);

    //Таким образом наш Крип сейчас дерётся так, будто бы части тела не отламываются до самой смерти, а враг всегда действует идеальным алгоритмом и сильнее в 2 раза
    return нашРейтинг / вражескийРейтинг;//Вощвращает не идеальный 1, а % хп который наш Крип успел бы отнять у вражеского крипа перед смертью
}


//ВНИМАНИЕ, ВСЁ ЧТО НИЖЕ НАПИСАНО НЕЙРОСЕТЬЮ И Я ПОКА НЕ ПОНИМАЮ В ПОЛНОЙ МЕРЕ КАК КОД РАБОТАЕТ
//ПЕРЕПИШУ КОД НА СВОЙ УЖЕ В СЛЕДУЮЩЕМ КОММИТЕ
// Возможные части тела
const ЧАСТИ_ТЕЛА = ["MOVE", "ATTACK", "RANGED_ATTACK", "HEAL", "TOUGH"];
// Класс нейронной сети
class ПростаяНейроннаяCетьС1Слоем {
    constructor() {
        // Веса: для каждой из 50 позиций — массив из 5 чисел (по числу типов частей)
        this.веса = [];
        for (let i = 0; i < 50; i++) {
            // Случайные веса от -1 до 1 для каждой части тела
            this.веса[i] = Array(5).fill(0).map(() => Math.random() * 2 - 1);
        }
        console.log(this.веса); // Выводим случайную комбинацию из 50 частей
    }

    // Функция предсказания: принимает вход (пока просто [1]) и возвращает комбинацию частей
    прогноз(вход) {
        const выход = [];
        for (let i = 0; i < 50; i++) {
            // Вычисляем "рейтинг" для каждой части тела
            let рейтинг = this.веса[i].map(weight => weight * вход[0]);
            // Выбираем часть с максимальным скором
            let максИндексРейтинга = рейтинг.indexOf(Math.max(...рейтинг));
            выход.push(ЧАСТИ_ТЕЛА[максИндексРейтинга]);
        }
        return выход;
    }
}

// Тестируем
const нс = new ПростаяНейроннаяCетьС1Слоем();
const телоКрипа = нс.прогноз([1]);
console.log(телоКрипа); // Выводим случайную комбинацию из 50 частей

