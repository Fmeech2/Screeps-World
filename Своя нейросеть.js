const MOVE = 1;
const ATTACK = 2;
const RANGED_ATTACK = 3;
const HEAL = 4;
const TOUGH = 5;

function нейрон(вход, вес) {
    let сумма = 0;
    //ѕеремножаем входные данные на вес
    for (let i = 0; i < вход.length; i++) {
        сумма = сумма + вход[i] * вес[i];
    }
    //јктивационна€ функци€ (сигмойда)
    return 1 / (1 + Math.exp(-сумма));
}

function обучение(вход, вес, ожидаемый_результат, скорость_обучени€) {
    let выход = нейрон(вход, вес);
    let ошибка = ожидаемый_результат - выход;

    // орректируем веса
    for (let i = 0; i < вес.length; i++) {
        вес[i] = вес[i] + скорость_обучени€ * ошибка * вход[i];//√ражиентный спуск (почему мы умнажаем на вход[i] € так и не пон€л)
    }
}

//“естируем код, на тестовых данных
let вход = [
    [MOVE, MOVE, ATTACK, ATTACK],
    [ATTACK, ATTACK, MOVE, MOVE],
    [TOUGH, MOVE, MOVE, ATTACK],
    [TOUGH, TOUGH, MOVE, MOVE],
    [MOVE, MOVE, RANGED_ATTACK, RANGED_ATTACK],
    [TOUGH, MOVE, MOVE, RANGED_ATTACK],
    [ATTACK, ATTACK, ATTACK, MOVE],
    [MOVE, ATTACK, ATTACK, ATTACK],

    [ATTACK, ATTACK, ATTACK, ATTACK],
    [MOVE, MOVE, MOVE, MOVE],
    [TOUGH, TOUGH, TOUGH, TOUGH],
    [HEAL, HEAL, HEAL, HEAL],
    [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK],
];
//let вес = [Math.random(), Math.random(), Math.random(),Math.random(), Math.random()];
let вес = [0.1, 0.1, 0.1, 0.1, 0.1];
let ожидаемый_результат = [
    7 / 9,
    7 / 9,
    4 / 9,
    0.01,
    (7 / 2) / 9,
    (4 / 2) / 9,
    6 / 9,
    9 / 9,

    0.1,
    0.1,
    0.05,
    0.05,
    0.2,
]; //—амый сильный ближний бой крип
let скорость_обучени€ = 0.1;

/*
console.log("ƒо обучени€:", вес);
for (let i = 0; i < 1000; i++) {
    for (j = 0; j < вход.length; j++) {
        обучение(вход[j], вес, ожидаемый_результат[j], скорость_обучени€);
    }
}
console.log("ѕосле обучени€:", вес);
console.log(нейрон(вход[0], вес) + " = 1?");
*/

























function оценитьћощь рипа(тело рипа, тело¬рага) {
    //”читываем замедление передвижение из-за перевеса крипа
    let усталость рипа = тело рипа.filter(часть“ела => часть“ела != "MOVE").length * 2 - тело рипа.filter(часть“ела => часть“ела === "MOVE").length * 2;
    if (усталость рипа <= 0) усталость рипа = 1;
    else усталость рипа = усталость рипа / 2 + 1;
    let усталость¬рага = 1; // ѕредполагаем, что враг всегда мобильный
    //ћожно будет в будующем легко мен€ть хп  рипу на входе, в зависимости от количества частей тела
    let хп рипа = 50 * 100;
    let хп¬рага = 50 * 100;
    // —имул€ци€ бо€ (в реальной игре это зависит от движка Screeps)
    // ¬озвращаем награду: 1 Ч победа, 0 Ч поражение
    let наш–ейтинг =
        (тело рипа.filter(часть“ела => часть“ела === "ATTACK").length * 30 +
            тело рипа.filter(часть“ела => часть“ела === "RANGED_ATTACK").length * 15)
        / усталость рипа
        * (5000 / хп рипа);
    //усталось крипа не добавл€етс€ вражескому крипу, потому что предполагаетс€ что крип будет учитьс€ на итак адекватном вражеском крипе, без 50 частей ј“ј »
    let вражеский–ейтинг =
        (тело¬рага.filter(часть“ела => часть“ела === "ATTACK").length * 30 +
            тело¬рага.filter(часть“ела => часть“ела === "RANGED_ATTACK").length * 30)
        / усталость¬рага
        * (5000 / хп¬рага);

    //“аким образом наш  рип сейчас дерЄтс€ так, будто бы части тела не отламываютс€ до самой смерти, а враг всегда действует идеальным алгоритмом и сильнее в 2 раза
    return наш–ейтинг / вражеский–ейтинг;//¬ощвращает не идеальный 1, а % хп который наш  рип успел бы отн€ть у вражеского крипа перед смертью
}



// ¬озможные части тела
const „ј—“»_“≈Ћј = ["MOVE", "ATTACK", "RANGED_ATTACK", "HEAL", "TOUGH", "ѕ”—“ќ"];


// лас ћќ≈… нейроной сети
class ѕростайќднослойна€Ќейросеть {
    веса = [];
    constructor() {
        //«аполн€ем все нейроны случайными весами дл€ каждой части тела | токинизаци€ 
        for (let i = 0; i < 50; i++) {
            this.веса[i] = [];//»нициирум массив, потому что так хочет JS
            for (let j = 0; j < „ј—“»_“≈Ћј.length; j++) {
                //“еперь у каждого слота под тело, будут все вариации весов всех тел | вес = от -1 до 1
                this.веса[i][j] = Math.random() * 2 - 1;
            }
        }
    }
    //‘ункци€ прогноза. Ќо € бы еЄ назвал "‘ункцией выбора лучшей комбинации частей тела дл€ крипа на основе знаний обученной »»" ..длинное название, не правда ли?
    прогноз() {
        const выход = [];
        const выход“окинизированный = [];
        for (let i = 0; i < 50; i++) {
            let индекс—ћакс–ейтингом = 0;
            //¬ыбираем токен/индекс части тела с максимальным рейтингом
            for (let j = 0; j < „ј—“»_“≈Ћј.length; j++) {
                if (this.веса[i][индекс—ћакс–ейтингом] > this.веса[i][j])
                    индекс—ћакс–ейтингом = j;
            }
            выход“окинизированный[i] = индекс—ћакс–ейтингом;
        }
        //ѕреобразуем массив токенов в массив соответствующих частей тела
        for (let i = 0; i < 50; i++) {
            выход[i] = „ј—“»_“≈Ћј[выход“окинизированный[i]];
        }
        return выход;
    }
}
//ѕробный запуск теста
const нс = new ѕростайќднослойна€Ќейросеть();
const тело рипа = нс.прогноз();
console.log(тело рипа);// ¬ыводим случайную комбинацию из 50 частей ƒЋя “≈—“ј


